# Making All Route protected with authentication and authorization (RBA)
## We will use Middleware 
- Runs on server side.
- Middleware runs before cached content and routes are matched.
- Middleware allows you to run code before a request is completed.
- Based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

### Make a file in root directory name `middleware.ts` 
```.ts
// This function can be marked `async` if using `await` inside
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/', request.url))
}

// See "Matching Paths" below to learn more
export const config = {
  matcher: '/products/:path*',
}
```
- In config, We can define which part will be matched.
- Suppose for we define in above in `matcher` : `'/products/:path'`
  - That means `localhost:3000/products/....`  -> every route after `products` will be matched,
  - like : `products/1`, `products/abc`
  - When we go to this routes, the middleware will runs before rendering in server side.

- return NextResponse.redirect(new URL('/', request.url)) -> this will redirect to '/' root instead of `request.url`
- `request.url` will get the whole path.

## Role base access.
- make a 3 files inside `_lib/auth`
  - role.ts
  - authorize.ts
  - route-permission.ts

```role.ts
export type Role = "admin" | 'customer';
```

```route-permission.ts
// lib/auth/route-permissions.ts
import { Role } from "@/app/_lib/auth/role";

export const routePermissions: {
    path: string;
    roles: Role[];
}[] = [
        { path: "/products/add", roles: ["admin"] },
        { path: "/products", roles: ["admin",'customer'] },
        
    ];
```

```authorize.ts
// lib/auth/authorize.ts
import { Role } from "./role";
import { routePermissions } from "./route-permissions";

export function isAuthorized(pathname: string, role: Role): boolean {
    const rule = routePermissions.find((r) =>
        pathname.startsWith(r.path)
    );

    if (!rule) return true; // public route

    return rule.roles.includes(role);
}
```
### Here the middleware code :
```
// middleware.ts
import { NextRequest, NextResponse } from "next/server";
import { isAuthorized } from "@/app/_lib/auth/authorize";
import { Role } from "@/app/_lib/auth/role";

export function middleware(request: NextRequest) {
    // const token = request.cookies.get("token")?.value;
    // const role = request.cookies.get("role")?.value as Role;

    const role: Role = 'customer'; // for now hardcoded, in real life it will retrieve from any type of storage
    const pathname = request.nextUrl.pathname;
    console.log(pathname,role)

    // if (!token) {
    //     return NextResponse.redirect(new URL("/login", request.url));
    // }

    if (!isAuthorized(pathname, role)) {
        return NextResponse.redirect(new URL("/unauthorized", request.url));
    }

    return NextResponse.next(); // if all right, it will pass to next
}
export const config = {
    matcher: [
        "/products/:path*",
    ],
};
```
